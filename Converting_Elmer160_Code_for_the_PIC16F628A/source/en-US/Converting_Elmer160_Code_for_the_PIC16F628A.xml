<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "Converting_Elmer160_Code_for_the_PIC16F628A.ent">
%BOOK_ENTITIES;
]>
<article status="draft">
  <xi:include href="Article_Info.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
  <section>
    <title>Introduction</title>
    <para>
      The original Elmer 160 course was written around the
      <application>PIC16F84A</application> microcontroller.  Even at
      the time this was a somewhat controversial decision.  The
      <application>PIC16F84A</application> is a relatively expensive
      part, and is the least capable of the 14-bit core PICs.
      However, this lack of capability leads to greater simplicity;
      something very worthwhile when learning a new subject.
    </para>
    <para>
      The American QRP Club kitted a device called the
      <application>PIC-EL</application>, designed by AA0ZZ and others,
      to go along with the course.  Eventually, the supply of kits ran
      out, but demand for the kit remained high.
    </para>
    <para>
      Craig Johnson, AA0ZZ, negotiated with Kanga U.S. to distribute
      an updated version of the <application>PIC-EL</application>.
      Having a commercial supplier meant that there could be an almost
      unlimited supply for future students.  The new,
      <application>PIC-EL II</application> however, used the
      <application>PIC16F628A</application> instead of the simpler
      <application>PIC16F84A</application>.
    </para>
    <para>
      There are a number of reasons to select the newer part:
      <itemizedlist>
	<listitem>
	  <para>It is considerably cheaper</para>
	</listitem>
	<listitem>
	  <para>It has twice the memory of the older part</para>
	</listitem>
	<listitem>
	  <para>It has additional, useful peripherals</para>
	</listitem>
	<listitem>
	  <para>It was not clear how much longer the <application>PIC16F84A</application> would be available</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      Later still the <application>PIC-EL III</application> was
      introduced, incorporating a USB programmer, but retaining the
      <application>PIC16F628A</application>.  Since few modern
      computers have the serial port required of the earlier devices,
      the <application>PIC-EL III</application> is the tool of choice
      for new students.  However, the lessons are written around the
      <application>PIC16F84A</application>.
    </para>
    <para>
      Since the <application>PIC16F628A</application> is significantly
      more complex than the <application>PIC16F84A</application>, new
      students are encouraged to obtain a
      <application>PIC16F84A</application> (which can be used in the
      newer boards) to follow the lessons.  Code for using other PICs
      is introduced later on in the lessons, so at that point it makes
      sense to use the <application>PIC16F628A</application>.  Indeed,
      there are quite a number of PICs that may be used in the
      <application>PIC-EL</application>, and for new designs, almost
      anything makes more sense than the
      <application>PIC16F84A</application>.  However, the
      <application>PIC16F84A</application> is far simpler, so it is
      recommended for beginners.
    </para>
    <para>
      Although the <application>PIC16F84A</application> is
      significantly more expensive than the
      <application>PIC16F628A</application>, it is still fairly
      inexpensive.  But it isn't something the student can pick up at
      the local hardware store, and as a result, shipping often costs
      several times the cost of the part.  As a consequence, many
      students choose to continue with the
      <application>PIC16F628A</application> in spite of the problems.
    </para>
    <para>
      Fortunately, most code is transportable between the various PICs
      within a family.  There are only a handful of changes necessary
      in the examples in the course.  This is a bit misleading since
      the user may be blindsided to some issues in his own code if
      attempted before getting to the parts of the course that explain
      the differences.
    </para>
    <para>
      The basic changes required are:
      <itemizedlist>
	<listitem>
	  <para>
	    There are obvious changes such as the processor name and
	    the name of the processor include file.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    There are additional configuration fuses.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    For the absolute code examples early in the lessons, the
	    general purpose registers start at a different address.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    In the <application>PIC16F628A</application> the general
	    purpose registers are banked. In the
	    <application>PIC16F84A</application>, they are not.  This
	    could lead to the student discovering that his variables
	    have suddenly disappeared for no apparent reason.  Without
	    a debugger, this could be very hard to diagnose.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Some special function registers appear in different banks
	    in the two processors.  This largely affects the
	    interrupts and the EEPROM, so the student is unlikely to
	    encounter this issue early on.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    The <application>PIC16F628A</application> includes a
	    comparator which is enabled by default.  If the student
	    wishes to use the comparator pins for ordinary I/O, the
	    comparator must be turned off.
	  </para>
	</listitem>
      </itemizedlist>
    </para>
  </section>

  <section>
    <title>Obvious Changes</title>
    <para>
      There are a number of obvious issues to deal with.  First,
      perhaps most obvious, select the
      <application>PIC16F628A</application> as the processor type in
      <application>MPLAB</application>.  Choose <guimenuitem>Select
      Device ...</guimenuitem> from the <guimenu>Configure</guimenu>
      menu, scroll down to the correct device.
      <figure float="0">
	<title>Selecting the processor in MPLAB</title>
        <mediaobject>
          <imageobject>
	  <imagedata scale="50" scalefit="1" 
		     fileref="images/628-selectdevice.png" format="PNG"/>
	  </imageobject>
          <textobject>
	    <para>
              Selecting the processor in MPLAB
            </para>
          </textobject>
        </mediaobject>
      </figure>
    </para>
    <para>
      Next, change the processor line in the source file:
<screen>
        processor   pic16f628a
</screen>
    </para>
    <para>
      Thirdly, change the name of the processor include file:
<screen>
        include     "P16F628A.INC"
</screen>
    </para>
    <para>
      <note>
	<title>Case Matters</title>
	<para>
	  Maybe not now, but perhaps later
	</para>
      </note>
      In <application>MPLAB</application> 8 and earlier, the case of
      the include file doesn't matter.  In most cases, the examples
      show the file name in lower case, because a number of students
      use <application>gpasm</application> which expects lower case
      file names.  However, the more recent
      <application>MPLAB-X</application> expects upper case names.
      Since <application>gpasm</application> complains about an upper
      case name, but still finds it, while
      <application>MPLAB-X</application> simply fails, it is probably
      preferable to use upper case names for the include file.
    </para>
  </section>

  <section>
    <title>Configuration Fuses</title>
    <para>
      The newer processor, with new features, of course includes
      additional configuration fuses.  Some of those fuses turn out to
      be important.  In the <application>PIC16F84A</application> the
      configuration fuse setting almost always looked like:
<screen>
                __config        _XT_OSC &amp; _WDT_OFF &amp; _PWRTE_ON
</screen>
      These particular settings are still generally used for the
      <application>PIC16F628A</application>.  They mean:
    </para>
    <para>
      <itemizedlist>
	<listitem><para>
	  <code>_XT_OSC</code> - Use a crystal between 4 and 10 MHz.
	</para></listitem>
	<listitem><para>
	  <code>_WDT_OFF</code> - Don't use the watchdog timer.  The
	  watchdog timer creates an interrupt at a specific interval
	  so if code hangs we could program a recovery.  Since we
	  don't have the code to handle this, we don't want an
	  interrupt occurring every few minutes.
	</para></listitem>
	<listitem><para>
	  <code>_PWRTE_ON</code> - Turn on the power up timer.  This
	  one isn't terribly important in most cases.  it simply
	  inserts a small delay before the program starts so that any
	  circuitry that may need a little time to stabilize before
	  processing can do so.
	</para></listitem>
      </itemizedlist>
    </para>
    <para>
      However, the <application>PIC16F628A</application> has a few
      other settings, some important, some not so much.
    </para>
    <para>
      <itemizedlist>
	<listitem><para>
	  <code>_LVP_OFF</code> - This one is quite important since
	  normally it should be OFF but the default is ON.  If this
	  bit is set to <code>_LVP_ON</code> (or omitted), then should
	  pin 10 become high, the processor will enter programming
	  mode.  On earlier (and later) PICs, a high voltage on
	  <code>MCLR</code> was required to enter programming mode.
	  On a few PICs introduced around the same time as the
	  <application>PIC16F628A</application>, this fuse allows in
	  the field programming with only a single power supply.
	  However, unless the circuitry takes this into account and
	  ensures the programming pin cannot become high at the wrong
	  time, an improper setting can cause surprising operation.
	</para></listitem>
	<listitem><para>
	  <code>_MCLRE_ON</code> - If set OFF, this allows
	  <code>MCLR</code> to be used as an input instead of
	  processor reset.  Since the
	  <application>PIC-EL</application> is not wired this way, in
	  most cases the student will want it ON.  This fuse defaults
	  "correctly".
	</para></listitem>
	<listitem><para>
	  <code>_BOREN_OFF</code> - This fuse controls a reset on brown
	  out (low voltage). This allows for special action to be
	  taken in the milliseconds before loss of power.  In most
	  cases of interest to students, this setting doesn't matter.
	</para></listitem>
	<listitem><para>
	  <code>_CP_OFF</code>, <code>_CPD_OFF</code> - These settings
	  control code protection.  If set on, the program memory or
	  EEPROM cannot be read by a programmer, meaning that
	  programming cannot be verified.  Typically these should
	  both be OFF, which is the default.
	</para></listitem>
      </itemizedlist>
    </para>
    <para>
      So, in most cases for the <application>PIC-EL</application>, the
      settings should be:
<screen>
                __config        _XT_OSC &amp; _WDT_OFF &amp; _PWRTE_ON &amp; _LVP_OFF &amp; _BOREN_OFF
</screen>
    </para>
  </section>

  <section>
    <title>General Purpose Register Address</title>
    <para>
      The <application>PIC16F84A</application> has 18 Special Function
      Registers (<code>SFR</code>s) with addresses from 0x00 to 0x0b
      in two banks.  The <application>PIC16F628A</application> has 33
      Special Function Registers with addresses fro 0x00 to 0x1f.  In
      the <application>PIC16F84A</application> the General Purpose
      Registers (<code>GPR</code>s) start at 0x0c. Since that space
      is taken on the <application>PIC16F628A</application> by
      SFRs, the GPRs don't start until 0x20.
    </para>
    <para>
      When writing absolute code, (Lessons 15 and earlier) the
      assembler cannot "allocate" GPR memory. It is up to the
      programmer to keep track of memory use.  In most cases this is
      done by assigning specific addresses for storage of each
      variable.  For example, In lesson 4 there is code like:
<screen>
; Variable Storage

Spot1   equ          H'30'   ; First program variable
Spot2   equ          H'31'   ; Second program variable
</screen>
    </para>
    <para>
      To convert a program from the
      <application>PIC16F84A</application> to the
      <application>PIC16F628A</application> it is necessary to modify
      each of those equivalences to ensure they are in the GPR region
      of memory for the target processor.
    </para>
    <para>
      If the student is unfamiliar with the program being ported, this
      can be problematic as there are many other uses of the
      <code>equ</code> statement, and the developer must understand
      each use to decide the correct action.  This operation can be
      highly error prone.
    </para>
    <para>
      The assembler provides a <code>cblock</code> directive which
      creates sequential <code>equ</code> statements.  This allows
      GPRs to be "allocated" in a single place, with a single starting
      address.  Most of the PIC Elmer code uses this method, because
      it makes it far easier to port programs to other processors.
      The programmer need only ensure that the range of the single
      block is within the GPR range of the target processor.
    </para>
    <para>
      Further, most of the PIC Elmer examples use few memory
      locations, and <code>cblock</code> addresses were selected that
      fall in the range of all the PICs. (All the 14 bit core parts
      except the <application>PIC16F84A</application> share the 0x20
      to 0x7f GPR range of the <application>PIC16F628A</application>.)
    </para>
    <para>
      So if the student should encounter something like:
<screen>
                cblock          H'0c'
                        Buttons             ; Storage for inputs
                        LEDs                ; Storage for outputs
                endc
</screen>
      it will be necessary to change the <code>H'0c'</code> to some
      higher value, at least <code>H'20'</code>, assuming the student
      is confident that the symbols point to GPR locations and don't
      have some other use.
    </para>
    <para>
      Of course, none of this matters in relocatable programs.
    </para>
  </section>

  <section>
    <title>Special Function Registers</title>
    <para>
      The <application>PIC16F628A</application> has thirty-three
      Special Function Registers in four banks.  Six of these are
      echoed in all banks; the same six as in the
      <application>PIC16F84A</application>.
    </para>
    <para>
      However, those registers that are not in all the banks are not
      always in the same banks as the
      <application>PIC16F84A</application>.  Fortunately, the most
      commonly used registers are.  <code>PORTA</code>,
      <code>TRISA</code>, <code>PORTB</code> and <code>TRISB</code>
      are all found in their familiar locations.
    </para>
    <para>
      <warning>
	<title>Warning</title>
	<para>Here there be dragons</para>
      </warning>
      Unfortunately, even this isn't as simple as it sounds.  The
      <code>TRIS</code> registers are in bank 1, as in the 84.  But,
      the student is likely to put most of his data in bank 0.  On the
      84, data in bank 0 also appears in bank 1, but that isn't the
      case in the <application>PIC16F628A</application>.  The data in
      bank 1 is different data than in bank 0.  Typically the
      programmer only sets the <code>TRIS</code> registers once in the
      program, and usually immediately switches back to bank 0.  In
      most cases, there is no need for the data at the time the
      <code>TRIS</code> registers are set up.
    </para>
    <para>
      However, there are cases where they student may well want to
      modify the <code>TRIS</code> registers during the execution of
      the program.  In those cases, the student must take care to
      recognize that data in bank 0 is not available at the same time
      as the TRIS register is visible.
    </para>
    <para>
      Things get more interesting with the EEPROM.  In the
      <application>PIC16F84A</application>, the <code>EEDATA</code>
      and <code>EEADR</code> registers are in bank 0, while the
      <code>EECON1</code> and <code>EECON2</code> registers are in
      bank 1.  This works our reasonably well as the programmer
      generally needs access to data when dealing with
      <code>EEDATA</code> and <code>EEADR</code>, but not the others.
      On the <application>PIC16F628A</application>, however, all these
      registers are in bank 1.  This not only means that the
      <code>banksel</code> directives need to be moved around when
      converting code, the the student must be alert to where the
      settings are as data is manipulated.
    </para>
    <para>
      Consider the following code for the
      <application>PIC16F84A</application>:
<screen>
Loop
        movf            Location, W     ; Location in EEPROM
        movwf           EEADR           ; Set the EEPROM address
        banksel         EECON1          ; Select bank for EECON1
        bsf             EECON1,RD       ; Initiate read
        banksel         EEDATA          ; Back to bank 0
        movf            EEDATA,W        ; Pick up the data
        movwf           Target          ; and store it off
        incf            Location,F      ; Point to next EEPROM loc
        decfsz          Index,F         ; Count down
        goto            Loop            ; Go do next location
</screen>
      The corresponding code for the
      <application>PIC16F628A</application> has a number of
      differences, both in the location and targets of the
      <code>banksel</code> directives:
<screen>
Loop
        movf            Location, W     ; Location in EEPROM
        banksel         EEADR           ; Select bank for EE regs
        movwf           EEADR           ; Set the EEPROM address
        bsf             EECON1,RD       ; Initiate read
        movf            EEDATA,W        ; Pick up the data
        banksel         Target          ; Back to bank 0
        movwf           Target          ; and store it off
        incf            Location,F      ; Point to next EEPROM loc
        decfsz          Index,F         ; Count down
        goto            Loop            ; Go do next location
</screen>
    </para>
  </section>

  <section>
    <title>Comparator</title>
    <para>
      On the <application>PIC16F84A</application>, all the pins at
      power up are configured as digital inputs.  A couple of pins
      have special functions that may be enabled, but on power up, all
      pins are digital inputs.  Students, therefore, are often
      surprised to see that is not the case on the
      <application>PIC16F628A</application>.  <code>RA0</code> through
      <code>RA3</code> are configured for analog at power up.
    </para>
    <para>
      These pins serve as comparator inputs on the 628, and cannot be
      used as ordinary digital I/O until the comparator is disabled.
      At first glance, doing this is fairly simple:
<screen>
      movlw     H'07'
      movwf     CMCON
</screen>
    </para>
    <para>
      Indeed, when used in the PIC-EL, this is typically all that is
      required for most applications.
    </para>
    <para>
      However, especially for your own applications, there is a dark side.
      <warning>
	<title>Warning</title>
	<para>It is possible to damage the PIC in software</para>
      </warning>
    </para>
    <para>
      PICs are extremely robust devices and can take a startling
      amount of abuse, but in this area of analog inputs, there is a
      significant risk of damaging the part.
    </para>
    <para>
      On any PIC input which may accept an analog voltage, the pin
      defaults to analog rather than digital.  This is because an
      analog pin set to be a digital input and left unconnected may
      cause significant current to flow inside the part.  This current
      is capable of destroying the PIC.  This can also occur if the
      pin is set to digital and held at an intermediate voltage;
      i.e. neither fully true or fully false.
    </para>
    <para>
      This is not an issue on the PIC-EL because these pins are all
      pulled up.  They will remain at the supply voltage unless pulled
      down by a switch or the encoder.  But in any case, they cannot
      be left at an intermediate state on the PIC-EL.
    </para>
    <para>
      However, for other designs, the student must either ensure that
      the pin cannot face a high impedance, or not allow the pin to be
      in its digital input configuration.  Setting the pin to be a
      digital output is an acceptable strategy, as is leaving the
      comparator enabled.
    </para>
  </section>

  <section>
    <title>Staying Flexible</title>
    <para>
      While the PIC-EL includes a
      <application>PIC16F628A</application>, there are many other 18
      pin PICs the student may wish to try, and for projects on
      purpose-build boards, there is no reason to be limited to 18-pin
      parts.  All of the <application>PIC16</application> parts are
      very similar, and with a little care, code can be shared between
      them.
    </para>
    <para>
      The following are some 18 pin PICs that the student may wish to
      try for different purposes:
      <itemizedlist>
	<listitem>
	  <para>
	    <application>PIC16F627</application>,
	    <application>PIC16F627A</application>,
	    <application>PIC16F628</application>,
	    <application>PIC16F628A</application>,
	    <application>PIC16F648A</application> - These parts are
	    all virtually identical except for memory size.  The "A"
	    parts program faster, but for the hobbyist, that is of
	    little consequence.  The student may select between these
	    parts based on price and a project's memory requirements.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <application>PIC16F716</application> - This part includes
	    analog inputs and PWM outputs and is the least expensive
	    18 pin mid-range part.  However, it lacks EEPROM.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <application>PIC16F87</application>,
	    <application>PIC16F88</application> - these parts are the
	    top of the heap for mid-range 18 pin parts.  They include
	    lots of memory, a synchronous serial port for SPI and I2C,
	    an 8MHz internal oscillator and specialized low power features.
	    The difference between the two is that the 88 includes
	    analog inputs while the 87 does not.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <application>PIC16F818</application>,
	    <application>PIC16F819</application> - These are somewhat
	    middle of the road parts, including analog inputs and
	    EEPROM, but less expensive than the 87/88.
	  </para>
	</listitem>
      </itemizedlist>
      The enhanced mid-range parts
      (<application>PIC16F1xxx</application> - 4 digits) are more
      capable, but programming is slightly different.  For the
      hobbyist, it is probably preferable to move to the
      <application>PIC18F</application> family, which offers more
      capability with a similar difference in programming.  Students
      proficient in C may find the 16 bit parts
      (<application>PIC24F</application>,
      <application>PIC24H</application>,
      <application>PIC24E</application>,
      <application>dsPIC30F</application>,
      <application>dsPIC33F</application>,
      <application>dsPIC33E</application>), an even better choice.
      They are slightly more expensive, quite different, but far
      easier to use. The <application>PIC32</application> parts are
      even more powerful, but also more different.  At hobbyist
      quantities, the price difference, even for the 32 bit parts, is
      barely noticeable.
    </para>
    <para>
      Since differences in memory layout are handled more or less
      automatically by the linker, the student should move to
      relocatable code as quickly as possible (Lessons 16 and above).
      In addition, this offers the capability to take tested code and
      put it in a library for later use.  This can greatly speed
      future development.
    </para>
    <para>
      The student should consider using separate files for selecting
      the processor include file and configuration fuses.  In the
      later lessons, the include files
      <filename>Processor.inc</filename> and
      <filename>Configuration.inc</filename> select the processor
      include file and the "normal" configuration settings based on a
      processor symbol passed in from MPLAB.
    </para>
    <para>
      Many of the differences between PICs are shared by a number of
      families.  The <filename>Processor.inc</filename> file sets a symbol
      that can be tested for these various groups of processors.  For
      example, the symbol <code>PROC</code> is set to 627 for the 627,
      627A, 628, 628A and 648A, all of which share similar behavior.
      The programmer may then conditionalize code based on the family.
      For example:
<screen>
  IF ( PROC == 627 )
        movlw    H'07'
        movwf    CMCON
  ENDIF
</screen>
      would permit the code to be used on the 84A as well as the 628 and
      its sister parts
    </para>
    <para>
      The code in Lesson 21 has been tested extensively on all of the
      above processors, and demonstrates techniques for writing code
      that can be shared across the various PIC parts.
    </para>
    <para>
      Code tends to have a life of its own, and code you write today
      will very likely be copied at some time in the future for some
      other project.  If care is taken initially to allow the code to
      be flexible, this future re-use will be far less frustrating.
    </para>
  </section>
  <section>
    <title>Conclusions</title>
    <para>
      New students just learning microcontrollers would be well
      advised to replace the <application>PIC16F628A</application> on
      their PIC-EL with a <application>PIC16F84AA</application>. Doing
      so will make following the lessons far simpler.
    </para>
    <para>
      Students with some programming familiarity can still follow the
      course using the <application>PIC16F628A</application> by
      following a few simple steps, outlined in this document.
    </para>
    <para>
      Some of the more challenging issues in moving between different
      PICs are eased when relocatable programming (introduced in
      Lesson 16) is used.
    </para>
    <para>
      While many of the traps in changing processors are not apparent
      in the Elmer 160 lessons, the student will find that on new
      designs and circuits, issues may arise.  The later lessons,
      especially Lesson 21, address some of these issues.
    </para>
  </section>

  <xi:include href="Revision_History.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
<!--  <index /> -->
</article>

